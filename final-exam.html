<html>
<head>
    <title>CSCI-610 -- Final Exam</title>
    
    <!-- include vertex shaders -->

    <script id="wireframe-V" type="x-shader/x-vertex">
        #version 300 es
        in vec3 aVertexPosition;
        
        void main()
        {
            gl_Position = vec4(aVertexPosition, 1.0);
        }
    </script>

     <!-- wireframe fragment Shaders -->
     <script id="wireframe-F" type="x-shader/x-fragment">
         #version 300 es
         precision mediump float;
         
         // Color that is the result of this shader
         out vec4 fragColor;

         void main(void) {
             fragColor = vec4 (0.5, 0.5, 0.5, 1.0 );
         }

     </script>

     <script id="phong-V" type="x-shader/x-vertex">
         #version 300 es
         in vec3 aVertexPosition;
         in vec3 aVertexNormal;
         in vec2 aTextureCoord;

         uniform mat4 uModelViewMatrix;
         uniform mat4 uProjectionMatrix;
         uniform mat3 uNormalMatrix;

         out vec3 vNormal;
         out vec3 vPosition;
         out vec2 vTextureCoord;

         void main() {
            vec4 position = uModelViewMatrix * vec4(aVertexPosition, 1.0);
            vPosition = position.xyz;
            vNormal = normalize(uNormalMatrix * aVertexNormal);
            vTextureCoord = aTextureCoord;
            gl_Position = uProjectionMatrix * position;
         }
     </script>

     <script id="phong-F" type="x-shader/x-fragment">
         #version 300 es

         precision mediump float;

         in vec3 vNormal;
         in vec3 vPosition;
         in vec2 vTextureCoord;

         uniform vec3 uLightPosition;
         uniform vec3 uLightColor;
         uniform vec3 uAmbientColor;
         uniform vec3 uDiffuseColor;
         uniform vec3 uSpecularColor;
         uniform float uShininess;
         uniform bool uUseTexture;
         uniform sampler2D uSampler;

         out vec4 fragColor;

         void main() {
         // Calculate lighting vectors

            vec3 normal = normalize(vNormal);
            vec3 lightDir = normalize(uLightPosition - vPosition);
            vec3 viewDir = normalize(-vPosition);
            vec3 reflectDir = reflect(-lightDir, normal);

            // Ambient component
            vec3 ambient = uAmbientColor;

            // Diffuse component
            float diffuseIntensity = max(dot(normal, lightDir), 0.0);
            vec3 diffuse = uDiffuseColor * diffuseIntensity * uLightColor;

           // Specular component
            float specularIntensity = 0.0;
            if(diffuseIntensity > 0.0) {
                specularIntensity = pow(max(dot(viewDir, reflectDir), 0.0), uShininess);
            }
            vec3 specular = uSpecularColor * specularIntensity * uLightColor;

            // Texture or base color
            vec3 surfaceColor;
            if(uUseTexture) {
                surfaceColor = texture(uSampler, vTextureCoord).rgb;
            } else {
                surfaceColor = uDiffuseColor;
            }

            // Combine
            vec3 finalColor = surfaceColor * (ambient + diffuse) + specular;
            fragColor = vec4(finalColor, 1.0);
         }
     </script>

     <!-- Emissive/Portal Shader for Gates -->
     <script id="portal-V" type="x-shader/x-vertex">
        #version 300 es
        in vec3 aVertexPosition;
        in vec3 aVertexNormal;
        in vec2 aTextureCoord;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform float uTime;

        out vec3 vNormal;
        out vec2 vTextureCoord;
        out float vTime;

        void main() {
            vec4 position = uModelViewMatrix * vec4(aVertexPosition, 1.0);
            vNormal = aVertexNormal;
            vTextureCoord = aTextureCoord;
            vTime = uTime;
            gl_Position = uProjectionMatrix * position;
        }
    </script>

    <script id="portal-F" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec3 vNormal;
        in vec2 vTextureCoord;
        in float vTime;

        uniform vec3 uPortalColor;
        uniform float uPulseSpeed;
        uniform bool uUsePulse;

        out vec4 fragColor;

        void main() {
        // Create a pulsing glow effect
            float pulse = 1.0;
            if(uUsePulse) {
                pulse = sin(vTime * uPulseSpeed) * 0.3 + 0.7;
            }
            vec3 glowColor = uPortalColor * pulse;

        // Add edge brightening based on normal
            float edge = abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0)));
            edge = pow(edge, 3.0);

            vec3 finalColor = mix(glowColor * 0.5, glowColor*1.5, edge);
            float alpha = 0.9 - edge *0.5; //transparent at the edges

            fragColor = vec4(finalColor, alpha); // Semi-transparent
        }
    </script>

    <script id="hex-V" type="x-shader/x-vertex">
        #version 300 es
        in vec3 aVertexPosition;
        in ves3 aVertexNormal;

        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat3 uNormalMatrix;

        out vec3 vPosition;
        out vec3 vNormal;
        out vec3 vWorldPos;

        void main() {
            vec4 position = uModelViewMatrix * vec4(aVertexPosition, 1.0);
            vPosition = position.xyz;
            vNormal = normalize(uNormalMatrix * aVertexNormal);
            vWorldPos = aVertexPosition;
            gl_Position = uProjectionMatrix * position;
        }
    </script>

    <script id="hex-F" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        in vec3 vPosition;
        in vec3 vNormal;
        in vec3 vWorldPos;

        uniform vec3 uLightPosition;
        uniform vec3 uLightColor;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uGridSize;

        out vec4 fragColor;

        // Hexagonal grid function
        float hexDist(vec2 p) {
            p = abs(p);
            float c = dot(p, normalize(vec2(1.0, 1.73)));
            c = max(c, p.x);
            return c;
        }

        vec4 hexPattern(vec2 p) {
            vec2 grid = vec2(1.0, 1.73);
            vec2 offset = vec2(0.5, 0.5);

            vec2 p1 = p + offset;
            vec2 p2 = p - offset;

            vec2 h1 = p1 - grid * round(p1/grid);
            vec h2 = p2 - grid * round(p2/grid);

            float d1 = hexDist(h1);
            float d2 = hexDist(h2);
            float d = min(d1, d2);

            float hex = smoothstep(0.9, 1.0, d*uGridSize);
            return vec4(mix(uColor1, uColor2, hex), 1.0);
        }

        void main() {
            // Hexagonal pattern based on world position
            vec4 hexColor = hexPattern(vWorldPos.xz * 3.0);

            // Simple lighting
            vec3 normal = normalize(vNormal);
            vec3 lightDirection = normalize(uLightPosition - vPosition);
            float diffuse = max(dot(normal, lightDirection), 0.0);

            vec3 finalColor = hexColor.rgb * (0.3+0.7*diffuse);
            fragColor = vec4(finalColor, 1.0);
        }
    </script>

    // === Sky shaders ===
    <script id="sky-V" type="x-shader/x-vertex">
        #version 300 es
        in vec2 aPos;
        in vec2 aUV;
        out vec2 vUV;

        void main() {
            vUV = aUV;
            gl_Position = vec4(aPos, 0.0, 1.0);
        }
    </script>
    <script id="sky-F" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        in vec2 vUV;
        uniform sampler2D uSky;
        out vec4 fragColor;

        void main() {
            fragColor = texture(uSky, vUV);
        }
    </script>

    // Cloud shaders, procedural, no texture needed
    <script id="cloud-V" type="x-shader/x-vertex">
        #version 300 es
        in vec2 aPos;
        in vec2 aUV;
        out vec2 vUV;

        void main() {
            vUV = aUV;
            gl_Position = vec4(aPos, 0.0, 1.0);
        }
    </script>

    <script id="cloud-F" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        in vec2 vUV;

        uniform vec2 uCenter;
        uniform vec2 uScale;
        uniform float uTime;

        out vec4 fragColor;

        float blob(vec2 p, vec2 c, float r) {
            float d = length(p-c);
            return smoothstep(r, r * 0.6, d);
        }

        void main() {
            // map vUV into "cloud local space"
            vec2 p = (vUV - uCenter) / uScale;
            // animate slight drift
            p.x += 0.03 * sin(uTime * 0.3);

            // Build a cloud from a few soft blobs
            float a = 0.0;
            a += blob(p, vec2(-0.30, 0.00), 0.55);
            a += blob(p, vec2(0.00, 0.10), 0.65);
            a += blob(p, vec2(0.35, 0.00), 0.50);
            a += blob(p, vec2( 0.10,-0.18), 0.45);

            // Soften + clamp alpha
            a = clamp(a - 0.6, 0.0, 1.0);
            a = a * a;

            // white cloud with alpha
            fragColor = vec4(vec3(1.0), a * 0.75);
        }
    </script>
     
    <!-- Matrix library and code for standard transformations -->
    <script type="text/javascript" src="./gl-matrix-min.js"></script>

    <!-- shape functions -->
    <script type="text/javascript" src="./cgIShape.js"></script>

    <script type="text/javascript" src="./myShapes-min.js"></script>

    <!-- include the main final functions -->
    <script type="text/javascript" src="./finalMain.js"></script>

    <!-- keyboard functions -->
    <script type="text/javascript" src="./event.js"></script>
    
    <!-- texture images -->
     <img id="sky-texture" src="2_no_clouds_8k.png" style="display: none"> </img>
     <img id="chessboard-texture" src="ChessText2.jpg" style="display: none;">
     <img id="ground-texture" src="AbstractChessBoard.jpg" style="display: none;">
     <img id="hex-pattern-texture" src="HexPatternAdobe.jpg" style="display: none;">


  <script type="text/javascript">
    // Call init once the webpage has loaded
    window.onload = init;
  </script>

    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: #0a0a1a;
            color: #e0e0ff;
            margin: 20px;
        }

        h1 {
            color: #00ccff;
            text-shadow: 0 0 10px #00ccff;
        }

        h3 {
            color: #ff00cc;
        }

        canvas {
            border: 2px solid #00ccff;
            box-shadow: 0 0 20px #00ccff;
            background-color: #000015;
        }

        table {
            background-color: #1a1a2e;
            border-radius: 10px;
            padding: 15px;
        }

        td {
            padding: 10px;
            vertical-align: top;
        }

        td {
            padding: 10px;
            vertical-align: top;
        }

        .key {
            display: inline-block;
            background-color: #333355;
            padding: 4px 8px;
            margin: 2px;
            border-radius: 4px;
            font-family: monospace;
            border: 1px solid #6666cc;
        }

        .description {
            margin: 10px 0;
            color: #aaaaff;
        }

        .section-title {
            color: #00ffcc;
            margin-top: 15px;
            border-bottom: 1px solid #00ffcc;
            padding-bottom: 5px;
        }
    </style>

</head>

<body>
  <h1>CSCI-610: Final Exam Image</h1>
  <table>
      <tr>
          <td><canvas id="webgl-canvas" width="500" height="500">
            Your browser does not support the HTML5 canvas element.
          </canvas></td>
          
          <td>
              <div class="controls">
                  <h3>Controls</h3>

                  <div class="section-title">Camera Movement</div>
                  <div class="description">
                      <span class="key">W</span> / <span class="key">S</span> - Move forward/Back<br>
                      <span class="key">A</span> / <span class="key">D</span> - Strafe left/right<br>
                      <span class="key">Q</span> / <span class="key">E</span> - Move up/down<br>
                      <span class="key">G</span> / <span class="key">H</span> - Look up/down<br>
                      <span class="key">Y</span> / <span class="key">U</span> - Look left/right
                  </div>
              </div>

              <div class="section-title">Scene Controls</div>
              <div class="description">
                  <span class="key">1</span> - Toggle platforms texture<br>
                  <span class="key">2</span> - Toggle ground shader<br>
                  <span class="key">3</span> - Toggle portal animation<br>
                  <span class="key">4</span> - Toggle orb rotation<br>
                  <span class="key">L</span> - Toggle lighting<br>
                  <span class="key">R</span> - Reset camera<br>
                  <span class="key">+</span> / <span class="key">-</span> - Adjust grid size
              </div>

              <div class="section-title">Visual Effects</div>
              <div class="description">
                  <span class="key">TAB</span> - Cycles shader modes<br>
                  <span class="key">SPACE</span> - Pause/resume animation<br>
              </div>
          </td>
      </tr>
  </table>
</body>
</html>

